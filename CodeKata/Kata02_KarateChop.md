http://codekata.com/kata/kata02-karate-chop/

Kata02: Karate Chop
========================================

バイナリチョップ（二分探索法）は、ソートされた配列の中から目的の値の場所を見つける。

とにかく、どんな言語でも良いので二分探索ルーチンを実装してみよう。
ただし、後述する仕様に則ってください。

実装できたら、今度はまったく違うテクニックで5種類の二分探索ルーチンを実装してみよう。
例えば、良くあるループ処理や、再帰呼び出しとかいろいろ）


ゴール（目的）
----------------------------------------

このカタは、3つのゴールに分けられる。

1. いろんなアルゴリズムでコーディングすることで、ミスしたことをノートに記録しておく。二分探索法は、境界条件や植木算エラーに適している。日が経つにつれミスが減ってくる。
2. 自分で選んだテクニックの相対的な評価を理解してますか？プロダクションコードに適しているのはどれでしょうか？コーディングしてて楽しかったコードは？一番苦労したものは？自分で考えてみてください。
3. 5種類の二分探索法を考えるのは大変だったでしょう。4つ目と5つ目はどうやって思いつきましたか？


仕様
----------------------------------------

二分探索メソッドを実装するには、「目的の値」と「ソートされた配列」が必要。
目的の値が配列のどこにあるかを返す。見つからない場合は"-1"を返す。

`chop(int, array_of_int) -> int`

配列の要素数は100,000未満でOK。
性能やメモリのパフォーマンスは考えなくて良い。


テストデータ
----------------------------------------

筆者が使ったテストデータ。自由に使ってください。
ちなみに配列の添字は、ゼロ始まり。

```ruby
def test_chop
  assert_equal(-1, chop(3, []))
  assert_equal(-1, chop(3, [1]))
  assert_equal(0,  chop(1, [1]))
  #
  assert_equal(0,  chop(1, [1, 3, 5]))
  assert_equal(1,  chop(3, [1, 3, 5]))
  assert_equal(2,  chop(5, [1, 3, 5]))
  assert_equal(-1, chop(0, [1, 3, 5]))
  assert_equal(-1, chop(2, [1, 3, 5]))
  assert_equal(-1, chop(4, [1, 3, 5]))
  assert_equal(-1, chop(6, [1, 3, 5]))
  #
  assert_equal(0,  chop(1, [1, 3, 5, 7]))
  assert_equal(1,  chop(3, [1, 3, 5, 7]))
  assert_equal(2,  chop(5, [1, 3, 5, 7]))
  assert_equal(3,  chop(7, [1, 3, 5, 7]))
  assert_equal(-1, chop(0, [1, 3, 5, 7]))
  assert_equal(-1, chop(2, [1, 3, 5, 7]))
  assert_equal(-1, chop(4, [1, 3, 5, 7]))
  assert_equal(-1, chop(6, [1, 3, 5, 7]))
  assert_equal(-1, chop(8, [1, 3, 5, 7]))
end
```